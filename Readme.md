# JAVASCRIPT

## 2.1 Внешние скрипты, порядок исполнения

- Скрипты вставляются на страницу как текст в теге ```js <script>```, либо как внешний файл через ```js <script src="путь"></script>```
- Специальные атрибуты `async` и `defer` используются для того, чтобы пока грузится внешний скрипт – браузер показал остальную (следующую за ним) часть страницы. Без них этого не происходит.
- Разница между `async` и `defer`: атрибут `defer` сохраняет относительную последовательность скриптов, а `async` – нет. Кроме того, `defer` всегда ждёт, пока весь HTML-документ будет готов, а `async` – нет.

- Скрипты, которые вызовоются с скрипта по умолчанию `async`

## 2.3 Современный стандарт, `use strict`

Директива `use strict`

```js
'use strict';
```

Если написать эту директиву только в функции, строгий режим будет использоваться только там.

### ES5-shim

Браузер IE8 поддерживает только совсем старую версию стандарта JavaScript, а именно ES3.

К счастью, многие возможности современного стандарта можно добавить в этот браузер, подключив библиотеку `ES5 shim`, а именно – скрипты `es5-shim.js` и `es5-sham.js` из неё.

## 2.4 Переменные

```js
var COLOR_RED = "#F00"; // Константы. По сути они не константы, их можно менять
var COLOR_GREEN = "#0F0";
var COLOR_BLUE = "#00F";
var COLOR_ORANGE = "#FF7F00";

var color = COLOR_ORANGE; // Переменная
alert( color ); // #FF7F00
```

## 2.7 Шесть типов данных, typeof

**`Примитивные`**
- `number` (Infinity, NaN)
- `string`
- `boolean`

```js
var checked = true;
checked = false;
```

- Спец. значение `null` - Это тоже тип, который не относится к другим.
- Спец. значение `undefined` - Это тоже тип как `null`.

```js
var x;
console.log(x); // Значение не присвоено, но переменная объявлена
```

**`Object type`**

```js
var user = { name: "Вася" };
```

**`Оператор typeof`**

Работают они одинаково, но первый синтаксис короче.

- Синтаксис оператора: typeof x.
- Синтаксис функции: typeof(x).

## 2.8 Основные операторы

### **Преобразование к числу, унарный плюс `+`**

```js
var apples = "2";
var oranges = "3";

alert( apples + oranges ); // "23", так как бинарный плюс складывает строки
alert( +apples + +oranges ); // 5, число, оба операнда предварительно преобразованы в числа
```

**

### **Оператор запятая**

Запятая позволяет перечислять выражения, разделяя их запятой ','. Каждое из них – вычисляется и отбрасывается, за исключением последнего, которое возвращается.

```js
var a = (5, 6);

alert( a );  // 6
```

```js
// три операции в одной строке
for (a = 1, b = 3, c = a*b; a < 10; a++) {
 ...
}
```

## 2.9 Операторы сравнения и логические значения

`>= > < <=` - сравнения, `== !=` - равенство. (Сравнение проводить к числу, а равенство нет)

Для проверки равенства без преобразования типов используются операторы строгого равенства === (тройное равно) и !==.

### Сравнение с `null` и `undefined`

- Значения `null` и `undefined` равны == друг другу и не равны чему бы то ни было ещё. Это жёсткое правило буквально прописано в спецификации языка.
- При преобразовании в число `null` становится `0`, а `undefined` становится `NaN`.

Результат:

```js
alert(null > 0); // false
alert(null == 0); // false
alert(null >= 0); // true, приводится к числу (null->0, undefined->NaN). Смысл выше
```

### Несравнимый undefined

Значение undefined вообще нельзя сравнивать:

```js
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

- Сравнения `(1)` и `(2)` дают `false` потому, что `undefined` при преобразовании к числу даёт `NaN`. А значение `NaN` по стандарту устроено так, что сравнения `==, <, >, <=, >=` и даже `===` с ним возвращают false.
- Проверка равенства `(3)` даёт `false`, потому что в стандарте явно прописано, что `undefined` равно лишь `null` или себе и ничему другому

```js
var a, b = NaN, c = null;
console.log(a == b);  // false
console.log(a === b); // false
console.log(a == c);  // true
console.log(a === c); // false
```

## 2.10 Побитовые операторы

